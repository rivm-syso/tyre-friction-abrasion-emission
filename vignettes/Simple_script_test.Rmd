---
title: "Testing book code optimasation"
output: md_document
editor_options: 
  chunk_output_type: console
---

Goal is to replicate the scripting and use maneuvre functions and data instead. The newly updated [Base functions.R]{.underline} file is used.

The script is taken from IDIADA_motorway_viii.R.

```{r}


# Leon Tyre Test Track Simulations Rural v

## Input vehicle specifications Ford Escape Kuga

#Vehicle mass in kg
m_vehicle= 1660
#Vehicle surface area in m^2
A_vehicle=2.629
#Vehicle aerodynamic drag coefficient
c_drag= 0.347
#Vehicle acceleration from 0-100 km.h^-1 in s
t_0_100kmh_vehicle= 9.2

# Fraction of vehicle mass that consists of rotating parts (kg/kg)
frac_mass_rotate_parts_vehicle = runif(n=1000, 0.13,0.15)

## Input tyre performance data

tyre_name ="Linglong"
# minimum roll coefficient (kg/t) according to EU label
c_roll_tyre_min = 7.8
# maximum roll coefficient (kg/t) according to EU label
c_roll_tyre_max = 9.0
# minimum grip index according to EU label
grip_index_tyre_min = 1.25
# maximum grip index according to EU label
grip_index_tyre_max = 1.39
# indicate track underground as "dry asphalt" or "wet asphalt"
track_underground = "dry_asphalt"


#### setup tyre grip performance simulation
grip_index_tyre = runif(n=1000,grip_index_tyre_min,grip_index_tyre_max)
#### peak friction coefficient of reference tyre under reference conditions in EU wet grip tests
mu_max_ref_tyre_wet = 0.85

## Physics data ##
### Gravitational constant in m.s^-2
grav_constant = 9.81

# Source tyre friction funtions
source("R/Base functions.R")

### linearity slip and friction correction at wet and dry asphalt
if (track_underground == "wet_asphalt") {
  x_correct_road = 1
}


if (track_underground == "dry_asphalt") {
  x_correct_road = runif(n = 1000, 1.07, 1.47)
}


```

```{r normal_load_force}
## Setup vehicle parameters for track friction simulations

### Normal load force of vehicle (N) performed in downwards direction
normal_load_force <- f_normal_load_force(m_vehicle, grav_constant)
```

The new base functions now include slope in calculation of `normal_load_force`.

1.  But where is this normal_load_force used?

2.  Also, define variables, as you can see errors occur with just mentioning them with incorrect order...

```{r c_accel_max}
### Vehicle maximum acceleration constant (m.s^-2)
c_accel_max <-f_c_accel_max(t_0_100kmh_vehicle)
```

1.  Where is `c_accel_max` used?

2.  Function `f_c_accel_max` also not available in Base functions.

```{r m_rotate}
### mass (kg) of rotating parts
m_rotate = f_m_rotate(frac_mass_rotate_parts_vehicle=frac_mass_rotate_parts_vehicle, 
                      m_vehicle=m_vehicle)
```

m_rotate is uncertain and is typically between 13 and 15 percent of the vehicle weight (REF needed).

```{r f_mu_max}
#### calculate peak friction coefficient between tyre and track
mu_max_tyre_track = f_mu_max_tyre_track(grip_index_tyre=grip_index_tyre, 
                                        x_correct_mu_max_track=x_correct_road, 
                                        wet_mu_max_ref_tyre=mu_max_ref_tyre_wet)
```

The peak friction coefficient is calculated using an uncertain conversion of tyre label to grip index and wet grip index to dry grip index to calculate the peak friction coefficient between the tyre and the track.

```{r}
#### calculate linear increase constant 'x' for track
x_slip_long_force_tyre_track <- f_x_slip_long_force(grip_index_tyre, 
                                                    x_correct_road, 
                                                    mu_max_ref_tyre_wet, 
                                                    optimal_slip)


```

The is quite a departure here in Base function in how slip linearity here is used. There are now seperate functions per maneuvre.

1.  How is with deceleration accounted for when it is just wheel slip and when breaking slip?

```{r rest}



#### brake deceleration constant of reference tyre under reference conditions in EU wet grip tests
c_full_brake_ref_tyre_wet = 0.68*grav_constant
### calculate track-tyre deceleration constant (m.s^-2) at full wheel lock braking
c_full_brake_tyre_track <- f_c_full_brake(grip_index_tyre, x_correct_road, c_full_brake_ref_tyre_wet)
#### tyre roll coefficient as range
c_roll =runif(n=1000, c_roll_tyre_min,c_roll_tyre_max)/1000



# IDIADA track simulations

## Sector 1st brake sector input

sector_distance = (3193-940)*2
sector_velocity_kmh = 130
sector_start_velocity_kmh = 50
sector_end_velocity_kmh = 50
sector_underground = "dry asphalt"
sector_alpha_slope = 0
alpha_slope = sector_alpha_slope
sector_latitude = 0 
sector_corner_radius = 0
sector_bank_slope = 0
sector_corner_angle = 0
sector_decel_g = 2.94/grav_constant
c_decel= sector_decel_g*grav_constant
sector_accel_g= 1.5/grav_constant
c_accel= sector_accel_g*grav_constant

sector_1_repeats = 1

## Sector 1 straight sector simulations
IDIADA_accel_distance_sector_1 = f_accel_distance(sector_start_velocity_kmh, sector_velocity_kmh , c_accel)
IDIADA_accel_slip_sector_1 = f_accel_slip(c_drag, A_vehicle, rho_air,sector_start_velocity_kmh, sector_velocity_kmh, v_wind, c_roll, m_vehicle, grav_constant, alpha_slope, m_rotate, c_accel, grip_index_tyre, x_correct_road, mu_max_ref_tyre_wet, optimal_slip)
IDIADA_accel_friction_work_sector_1 = f_accel_friction_work(optimal_slip, x_slip_long_force, c_drag, A_vehicle, rho_air,sector_start_velocity_kmh, sector_velocity_kmh, v_wind, c_roll, m_vehicle, grav_constant, alpha_slope, m_rotate, c_accel)

IDIADA_decel_distance_sector_1 =f_decel_distance(sector_velocity_kmh, sector_end_velocity_kmh , c_decel)
IDIADA_decel_slip_sector_1 = f_decel_brake_slip(c_decel, c_drag, A_vehicle, rho_air, sector_velocity_kmh, sector_end_velocity_kmh , v_wind, c_roll, m_vehicle, grav_constant ,alpha_slope, m_rotate, grip_index_tyre, x_correct_road, c_full_brake_ref_tyre_wet)
IDIADA_decel_friction_work_sector_1 = f_decel_friction_work(optimal_slip, x_slip_long_force, c_drag, A_vehicle, rho_air, sector_velocity_kmh, sector_end_velocity_kmh , v_wind, c_roll, m_vehicle, grav_constant , alpha_slope, c_decel, m_rotate, grip_index_tyre, x_correct_road,c_full_brake_ref_tyre_wet)

IDIADA_const_speed_distance_sector_1 = f_const_speed_distance(sector_distance,sector_start_velocity_kmh, sector_velocity_kmh , c_accel, sector_end_velocity_kmh , c_decel)
IDIADA_const_speed_slip_sector_1 = f_const_speed_slip(m_vehicle, grav_constant, alpha_slope, c_drag, A_vehicle, rho_air, sector_velocity_kmh, v_wind,c_roll, m_rotate, grip_index_tyre, x_correct_road, c_full_brake_ref_tyre_wet)
IDIADA_const_speed_friction_work_sector_1 = f_const_speed_friction_work(sector_distance,sector_start_velocity_kmh, sector_velocity_kmh , c_accel, sector_end_velocity_kmh , c_decel, c_drag, A_vehicle, rho_air, v_wind , c_roll, m_vehicle, grav_constant , alpha_slope, grip_index_tyre, x_correct_road, c_full_brake_ref_tyre_wet)

```

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
