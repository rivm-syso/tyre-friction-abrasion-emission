---
title: "Testing book code optimasation"
output: md_document
editor_options: 
  chunk_output_type: console
---

*Goal is to replicate the scripting and use maneuvre functions and data instead. The newly updated [Base functions.R]{.underline} file is used.*

*The script is taken from IDIADA_motorway_viii.R.*

```{r data}
library(tidyverse)
# 
# # Leon Tyre Test Track Simulations Rural v
# 
# ## Input vehicle specifications Ford Escape Kuga
# 
# #Vehicle mass in kg
# m_vehicle= 1660
# #Vehicle surface area in m^2
# A_vehicle=2.629
# #Vehicle aerodynamic drag coefficient
# c_drag= 0.347
# #Vehicle acceleration from 0-100 km.h^-1 in s
# t_0_100kmh_vehicle= 9.2
# 
# # Fraction of vehicle mass that consists of rotating parts (kg/kg)
# frac_mass_rotate_parts_vehicle = runif(n=1000, 0.13,0.15)
# 
# ## Input tyre performance data
# 
# tyre_name ="Linglong"
# # minimum roll coefficient (kg/t) according to EU label
# c_roll_tyre_min = 7.8
# # maximum roll coefficient (kg/t) according to EU label
# c_roll_tyre_max = 9.0
# # minimum grip index according to EU label
# grip_index_tyre_min = 1.25
# # maximum grip index according to EU label
# grip_index_tyre_max = 1.39
# # indicate track underground as "dry asphalt" or "wet asphalt"
# track_underground = "dry_asphalt"
# 
# 
# #### setup tyre grip performance simulation
# grip_index_tyre = runif(n=1000,grip_index_tyre_min,grip_index_tyre_max)
# #### peak friction coefficient of reference tyre under reference conditions in EU wet grip tests
# mu_max_ref_tyre_wet = 0.85
# 
# ## Physics data ##
# ### Gravitational constant in m.s^-2
# grav_constant = 9.81
# 
# # Source tyre friction funtions
source("R/Base functions.R")
# 
# ### linearity slip and friction correction at wet and dry asphalt
# if (track_underground == "wet_asphalt") {
#   x_correct_road = 1
# }
# 
# 
# if (track_underground == "dry_asphalt") {
#   x_correct_road = runif(n = 1000, 1.07, 1.47)
# }


n.Runs = 1000
local_path <- "C:/Users/quikj/rivm.nl/LEON-Tyres - WP3 Microplastics/Data/TWP emission data_IDIADA_v01.xlsx"

local_path <- "data/TWP emission data_IDIADA_v01.xlsx"
Maneuver_data <- readxl::read_excel(path = local_path, sheet = "Maneuver data")
Sector_data <- readxl::read_excel(path = local_path, sheet = "Sector data")
Vehicle_data <- readxl::read_excel(path = local_path, sheet = "Vehicle data")

Tyre_data <- readxl::read_excel(path = local_path, sheet = "Tyre_data")

Constants <- readxl::read_excel(path = local_path, sheet = "Constants")
Grip_Index_convtable <- readxl::read_excel(path = local_path, sheet = "Label fuel efficiency class")
Fuel_Eff_convtable <- readxl::read_excel(path = local_path, sheet = "Label wet grip class")


source("R/Tyrelabel_conversion.R")

#TODO: selection based on track, maneuver code, tyre and verhicle
c_roll_uniform <- runif(n.Runs, fRolCoef_Tlabel(Label_fuelleff = 
                                                  Tyre_data$`Fuel efficiency class`[1],
                                                vehicle_class = 
                                                  Tyre_data$Vehicle_class)$min,
                        fRolCoef_Tlabel(Label_fuelleff = 
                                          Tyre_data$`Fuel efficiency class`[1], 
                                        vehicle_class = 
                                          Tyre_data$Vehicle_class)$max)

```

*The basic approach to calculating friction force is estimating the distance a maneuvre is taking place, the slip and forces.*

*The forces are calculated using these functions:*

-   *f_accel_long_force*

-   *f_decel_long_force*

-   *f_const_speed_long_force*

-   *f_lat_force*

```{r f_accel_long_force}

# for one tyre and one sector and one maneuvre:

#TODO: selection based on track, maneuver code, tyre and verhicle

test_accel_Force <- f_accel_long_force(c_roll = c_roll_uniform, 
                   m_vehicle = Vehicle_data$`Mass (kg)`[1],
                   grav_constant = Constants |> 
                     filter(Name == "grav_constant") |> pull(value),
                   c_drag = Vehicle_data$`Aero_drag_coef (-)`[1],
                   A_vehicle = Vehicle_data$`Surface_Area (m2)`[1], 
                   rho_air = Constants |> 
                     filter(Name == "rho_air") |> pull(value), 
                   v_start_accel = Maneuver_data$`Start speed (m/s)`[1], 
                   v_end_accel = Maneuver_data$`End speed (m/s)`[1], 
                   v_wind = 0, # uniform distribution of variability? 
                   alpha_slope = Sector_data$`Longitudinal slope (%)`[1], 
                   m_rotate = runif(n.Runs,
                                    Constants |> 
                     filter(Name == "min_rotating_fraction") |> pull(value),
                     Constants |> 
                     filter(Name == "max_rotating_fraction") |> pull(value)), 
                   c_accel = Maneuver_data$`Acceleration constant (m.s^-2)`[1])


```

```{r f_const_speed_long_force}


test_const_Force <- f_const_speed_long_force(c_roll = c_roll_uniform, 
                   m_vehicle = Vehicle_data$`Mass (kg)`[1],
                   grav_constant = Constants |> 
                     filter(Name == "grav_constant") |> pull(value),
                  c_drag = Vehicle_data$`Aero_drag_coef (-)`[1],
                  A_vehicle = Vehicle_data$`Surface_Area (m2)`[1],
                   rho_air = Constants |> 
                     filter(Name == "rho_air") |> pull(value), 
                   v_vehicle = Maneuver_data$`Start speed (m/s)`[1], 
                   # v_end_decel = Maneuver_data$`End speed (m/s)`[1], 
                   v_wind = 0, # uniform distribution of variability? 
                   alpha_slope = Sector_data$`Longitudinal slope (%)`[1])


```

```{r f_decel_long_force}


test_decel_Force <- f_decel_long_force(c_roll = c_roll_uniform, 
                   m_vehicle = Vehicle_data$`Mass (kg)`[1],
                   grav_constant = Constants |> 
                     filter(Name == "grav_constant") |> pull(value),
                  c_drag = Vehicle_data$`Aero_drag_coef (-)`[1],
                  A_vehicle = Vehicle_data$`Surface_Area (m2)`[1],
                   rho_air = Constants |> 
                     filter(Name == "rho_air") |> pull(value), 
                   v_start_decel = Maneuver_data$`Start speed (m/s)`[1], 
                   v_end_decel = Maneuver_data$`End speed (m/s)`[1], 
                   v_wind = 0, # uniform distribution of variability? 
                   alpha_slope = Sector_data$`Longitudinal slope (%)`[1], 
                   m_rotate = runif(n.Runs,
                                  Constants |>
                   filter(Name == "min_rotating_fraction") |> pull(value),
                   Constants |>
                   filter(Name == "max_rotating_fraction") |> pull(value)),
                   c_decel = Maneuver_data$`Deceleration constant (m.s^-2)`)


```

```{r f_lat_force}

# m_vehicle , v_vehicle , r_corner, grav_constant, alpha_bank_slope

ttest_lat_force <- f_lat_force( m_vehicle = Vehicle_data$`Mass (kg)`[1],
                                grav_constant = Constants |> 
                                  filter(Name == "grav_constant") |> pull(value),
                                r_corner = Sector_data$`Corner radius (m)`[1],
                                alpha_bank_slope= Sector_data$`Latitudinal slope (%)`[1],
                                # rho_air = Constants |> 
                                #   filter(Name == "rho_air") |> pull(value), 
                                v_vehicle = Maneuver_data$`Start speed (m/s)`[1] # average of start and end?
)

```

*Slip is calculated using:*

-   *f_accel_long_slip*

-   *f_decel_long_slip*

-   *f_const_speed_long_slip*

-   *f_lat_slip*

```{r f_accel_long_slip}

f_accel_long_slip(c_roll = c_roll_uniform, 
                  m_vehicle = Vehicle_data$`Mass (kg)`[1], 
                  grav_constant = Constants |> 
                     filter(Name == "grav_constant") |> pull(value), 
                  c_drag = Vehicle_data$`Aero_drag_coef (-)`[1], 
                  A_vehicle = Vehicle_data$`Surface_Area (m2)`[1], 
                  rho_air = Constants |> 
                     filter(Name == "rho_air") |> pull(value),
                  v_start_accel = Maneuver_data$`Start speed (m/s)`[1], 
                  v_end_accel = Maneuver_data$`End speed (m/s)`[1], 
                  v_wind = 0, # uniform distribution of variability?  
                  alpha_slope = Sector_data$`Longitudinal slope (%)`[1], 
                  m_rotate = runif(n.Runs,
                                    Constants |> 
                     filter(Name == "min_rotating_fraction") |> pull(value),
                     Constants |> 
                     filter(Name == "max_rotating_fraction") |> pull(value)), 
                  c_accel = Maneuver_data$`Acceleration constant (m.s^-2)`[1], 
                  optimal_slip_ratio_track)
```

*The distance is calculated using:*

-   *f_accel_distance*

-   *f_decel_distance*

-   *f_corner_distance*

```{r normal_load_force}
## Setup vehicle parameters for track friction simulations

### Normal load force of vehicle (N) performed in downwards direction
normal_load_force <- f_normal_load_force(m_vehicle=m_vehicle, grav_constant)
```

*The new base functions now include slope in calculation of `normal_load_force`.*

1.  *But where is this normal_load_force used?*

2.  *Also, define variables, as you can see errors occur with just mentioning them with incorrect order...*

```{r c_accel_max}
### Vehicle maximum acceleration constant (m.s^-2)
# helper function, only relevant wehen c_accel is missing.
c_accel_max <-f_c_accel_max(t_0_100kmh_vehicle)
```

1.  *Where is `c_accel_max` used? It is used when the acceleration rate is not known and needs to be estimated based on vehicle specifications, such as time to 100 kph.*

```{r m_rotate}
### mass (kg) of rotating parts
m_rotate = f_m_rotate(frac_mass_rotate_parts_vehicle=frac_mass_rotate_parts_vehicle, 
                      m_vehicle=m_vehicle)
```

*m_rotate is uncertain and is typically between 13 and 15 percent of the vehicle weight (REF needed).*

```{r f_mu_max}
#### calculate peak friction coefficient between tyre and track
mu_max_tyre_track = f_mu_max_tyre_track(grip_index_tyre=grip_index_tyre, 
                                        x_correct_mu_max_track=x_correct_road, 
                                        wet_mu_max_ref_tyre=mu_max_ref_tyre_wet)
```

*The peak friction coefficient is calculated using an uncertain conversion of tyre label to grip index and wet grip index to dry grip index to calculate the peak friction coefficient between the tyre and the track.*

```{r}
#### calculate linear increase constant 'x' for track
x_slip_long_force_tyre_track <- f_x_slip_long_force(grip_index_tyre, 
                                                    x_correct_road, 
                                                    mu_max_ref_tyre_wet, 
                                                    optimal_slip)


```

*The is quite a departure here in Base function in how slip linearity here is used. There are now seperate functions per maneuvre.*

1.  *How is with deceleration accounted for when it is just wheel slip and when breaking slip?splayed.*
